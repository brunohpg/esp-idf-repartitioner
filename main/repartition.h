
#include <stdio.h>
#include "freertos/FreeRTOS.h"
#include "esp_ota_ops.h"
#include "esp_err.h"
#include "nvs_flash.h"
#include "nvs.h"
#include <esp_log.h>


#define PARTITION_OTA_1_TARGET_SIZE 0x180000
#define PARTITION_VFS_OFFSET 0x2D0000
#define PARTITION_VFS_SIZE 0x100000

static const char final_table[] = {
    0xaa, 0x50, 0x01, 0x02, 0x00, 0x90, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x6e, 0x76, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xaa, 0x50, 0x01, 0x00, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x6f, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xaa, 0x50, 0x00, 0x10, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x14, 0x00, 0x61, 0x70, 0x70, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xaa, 0x50, 0x00, 0x11, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x18, 0x00, 0x61, 0x70, 0x70, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xaa, 0x50, 0x01, 0x81, 0x00, 0x00, 0x2d, 0x00, 0x00, 0x00, 0x10, 0x00, 0x76, 0x66, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xeb, 0xeb, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8e, 0x7e, 0x28, 0xcb, 0xb9, 0xbc, 0xa4, 0x01, 0xc9, 0xe1, 0x4b, 0x04, 0x3b, 0x13, 0x84, 0x11,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF

};

void write_partition_table(const char *new_table){
    esp_err_t ret = spi_flash_erase_range(CONFIG_PARTITION_TABLE_OFFSET, 0x1000);
    if(ret == ESP_OK){
        ESP_LOGI("repartition", "successful repartition");
        spi_flash_write(CONFIG_PARTITION_TABLE_OFFSET, new_table, 0x1000);

        //essential to erase the memory where the NVS is defined
        //to pass the data integrity check in _boot.py when micropython is booting.
        esp_err_t retNvs = spi_flash_erase_range(PARTITION_VFS_OFFSET, PARTITION_VFS_SIZE);
        ESP_LOGI("repartition", "NVS erased: %d", retNvs);

        nvs_flash_erase();
        nvs_flash_init();
        esp_restart();
    }
}

void print_partition_info(const esp_partition_t *p, char* message) {
    ESP_LOGI("repartition", ">%s", message);
    if(!p) {
        ESP_LOGI("repartition", "\t not found");
        return;
    }
    ESP_LOGI("repartition", "partition label: %s", p->label);
    ESP_LOGI("repartition", "\ttype: %d", p->type);
    ESP_LOGI("repartition", "\tsubtype: %d", p->subtype);
    ESP_LOGI("repartition", "\taddress: %d", p->address);
    ESP_LOGI("repartition", "\tsize: %d", p->size);
}

int check_upgraded_partitions() {
    const esp_partition_t *vfs = esp_partition_find_first(ESP_PARTITION_TYPE_APP, ESP_PARTITION_SUBTYPE_DATA_FAT, "vfs");
    const esp_partition_t *ota_0 = esp_partition_find_first(ESP_PARTITION_TYPE_APP, ESP_PARTITION_SUBTYPE_APP_OTA_0, NULL);
    const esp_partition_t *ota_1 = esp_partition_find_first(ESP_PARTITION_TYPE_APP, ESP_PARTITION_SUBTYPE_APP_OTA_1, NULL);
    const esp_partition_t *boot_partition = esp_ota_get_running_partition();

    print_partition_info(boot_partition, "Boot partition");
    print_partition_info(ota_0, "OTA 0");
    print_partition_info(ota_1, "OTA 1");
    print_partition_info(vfs, " VFS");

    //boot_partition->subtype == 16 is ota_0
    //boot_partition->subtype == 17 is ota_1
    if(ota_1->size == PARTITION_OTA_1_TARGET_SIZE && boot_partition->subtype == 16){
        ESP_LOGI("repartition", "Fully upgraded partition table");
        return 1;
    } 
    else if(boot_partition->subtype == 16 && ota_1 && ota_1->size == 1310720){ 
        ESP_LOGW("repartition", "Running from OTA0, write final table");
        write_partition_table(final_table);
        return 0;
    }
    else if(boot_partition->subtype == 17){
        ESP_LOGI("repartition", "Running from OTA1, wait until next update");
        return 0;
    }
    else {
        ESP_LOGI("repartition", "wrong state?");
        return 0;
    }
    return 0;
}

int repartition_device() {
    const esp_partition_t *ota_0 = esp_partition_find_first(ESP_PARTITION_TYPE_APP, 16, NULL);
    const esp_partition_t *ota_1 = esp_partition_find_first(ESP_PARTITION_TYPE_APP, 17, NULL);
    if(ota_0 != NULL && ota_1 != NULL){
        ESP_LOGI("repartition", "Modified partition scheme detected");
        return check_upgraded_partitions();
    }
    return 0;
}
